# 任务系统设计

> “清单分组、清单、任务分组、任务”四级实体及“任务无限递归”与“拖拽排序”

## Task

```sql
CREATE TABLE `task` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `parent_id` BIGINT DEFAULT NULL COMMENT '父任务ID，顶级任务为NULL',
  `list_id` BIGINT NOT NULL COMMENT '所属清单ID',
  `group_id` BIGINT DEFAULT NULL COMMENT '所属任务分组ID (可选)',
  `name` VARCHAR(255) NOT NULL,
  `content` TEXT,
  `path` VARCHAR(1000) DEFAULT '' COMMENT '层级路径: "1/5/12/"',
  `level` INT DEFAULT 1 COMMENT '递归深度',
  `sort_order` DOUBLE NOT NULL DEFAULT 0 COMMENT '排序值',
  `status` TINYINT DEFAULT 0 COMMENT '状态: 0-待办, 1-完成, 2-已过期',
  `due_date` DATETIME DEFAULT NULL COMMENT '截止日期',
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  -- 索引优化
  INDEX `idx_list_group_sort` (`list_id`, `group_id`, `sort_order`),
  INDEX `idx_parent_id` (`parent_id`),
  INDEX `idx_path` (`path`(255))
) COMMENT='任务表';
```

### 增删改查逻辑

#### 1 添加 (Create)

- **sort_order 初始化**:
  - 如果是该层级/分组下的第一个任务：设置 `sort_order = 10000.0` (留出前后空间)。
  - 如果是在末尾添加：查询当前层级 `MAX(sort_order) + 10000.0`。
  - 如果是将一个任务移动在第一位：`new_sort_order = min_order / 2`。假设最小值是 `10000.0`，移动到第一位就变成 `5000.0`，再移一个变成 `2500.0`。这样可以始终保持为正数且向 `0` 无限趋近。
- **状态 (Status) 计算**:
  - 逻辑层：如果 `due_date != null` 且 `due_date < now()`，则初始状态标记为 `2 (已过期)`。
  - 建议：`status` 字段仅存储用户手动触发的状态（完成/待办），“是否逾期”可以通过 SQL 或代码动态判断：`is_overdue = (due_date < now() && status != DONE)`。

#### 2 修改 (Update)

- **updated_time**: **必须添加**。利用 MySQL 的 `ON UPDATE CURRENT_TIMESTAMP` 自动维护。
- **排序移动 (取中间值算法)**:
  - 当任务从位置 A 移动到位置 B 之间：`new_sort_order = (A.sort_order + B.sort_order) / 2`。
  - 该操作仅需 `UPDATE` 一行数据，不会产生连锁反应。

#### 3 查询 (Query)

针对你提到的“子任务需要显示父任务 ID 和名称”的需求，DTO 设计如下：

```
@Data
public class TaskDTO {
    private Long id;
    private String name;
    private Long parentId;
    private String parentName; // 仅子任务需要
    private Integer subTaskCount; // 子任务数量
    private Boolean hasChildren; // 是否有子任务
    private List<TaskDTO> children; // 树形结构使用
    // ... 其他字段
}
```

- **查询全部任务 (带有父节点信息)**:
  - 如果是子任务（`parent_id != null`），通过 `LEFT JOIN` 获取父任务名称。
- **查询清单下的任务 (含分组)**:
  - 逻辑：先查出该 `list_id` 下所有的 `TaskGroup`，再按 `group_id` 聚合 `Task`，全部按 `sort_order` 排序。

#### 4 删除 (Delete)

- **嵌套删除 (级联)**:
  - 传统的递归删除性能差。利用 `path` 字段：
  - `DELETE FROM task WHERE path LIKE '1/5/%' OR id = 5;`
  - 这一条语句即可瞬间删除 ID 为 5 的任务及其下所有无限层级的子任务。

## 3. 前端数据格式建议

### 3.1 清单详情页 (带分组的任务列表)

```
{
  "listName": "工作清单",
  "groups": [
    {
      "groupId": 101,
      "groupName": "紧急任务",
      "tasks": [
        {
          "id": 1,
          "name": "修复Bug",
          "hasChildren": true,
          "subTaskCount": 3,
          "sortOrder": 5000.0
        }
      ]
    },
    {
      "groupId": null, 
      "groupName": "未分组任务",
      "tasks": [...]
    }
  ]
}
```

### 3.2 子任务展示格式 

当用户进入某个子任务详情或在“全部”视图中查看时：

```
{
  "id": 12,
  "name": "具体子任务",
  "parentId": 5,
  "parentName": "父级需求分析",
  "pathInfo": [
    {"id": 1, "name": "顶级项目"},
    {"id": 5, "name": "父级需求分析"}
  ]
}
```