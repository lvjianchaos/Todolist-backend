# SmarToDo - 后端开发设计

> **文档版本**: v1.0 

## 1. 工程架构与规范 (Engineering Standards)

### 1.1 Maven 多模块结构

项目采用 Maven 父子工程结构，确保依赖版本统一管理。

```
smart-todo-backend (Root)
├── smart-todo-common           # [通用模块] Pojo, Utils, Constants, GlobalException
├── smart-todo-gateway          # [网关服务] 路由, 鉴权过滤器, 限流
├── smart-todo-auth             # [认证服务] 用户注册, 登录, JWT签发
├── smart-todo-task             # [任务服务] 核心业务 (List, Group, Task)
├── smart-todo-activity         # [动态服务] 日志记录, MQ消费者, Feed流查询
├── smart-todo-ai               # [AI服务] LLM对接, Prompt管理
└── smart-todo-api              # [Feign接口] 跨服务调用的接口定义 (Client SDK)
```

### 1.2 统一响应规约 (Response Envelope)

所有 HTTP 接口必须返回统一的 JSON 格式。

```
public class R<T> {
    private Integer code;   // 200:成功, 500:系统错误, 400:业务异常
    private String msg;     // 错误提示信息
    private T data;         // 业务数据 payload
    private Long timestamp; // 响应时间戳
}
```

### 1.3 异常处理规范

- **GlobalExceptionHandler**: 在 `common` 模块定义全局异常处理器，拦截 `BizException` (业务异常) 和 `Exception` (未知异常)。
- **错误码设计**:

## 2. 核心功能模块详细设计 (Module Design)

### 2.1 任务服务 (Task Service) - 端口 8020

这是系统的核心，承载四层级实体逻辑。

#### 2.1.1 核心业务流程

1. **用户初始化 (User Initialization)**
   - **触发**: 监听到 `UserRegisteredEvent` (来自 Auth 服务或 MQ)。
   - **事务逻辑**:
     1. Insert `list_group` (name="默认清单分组", is_default=true) -> get `groupId`.
     2. Insert `todo_list` (name="我的一天", group_id=groupId, is_default=true) -> get `listId`.
     3. Insert `task_group` (name="默认分组", list_id=listId, is_default=true).
   - **目的**: 保证新用户进来不是空白页。
2. **任务创建 (Task Creation)**
   - **输入**: `title`, `listId` (可选), `taskGroupId` (可选), `parentId` (可选)。
   - **逻辑**:
     - 若未传 `listId`，查询该用户的默认清单 ID。
     - 若未传 `taskGroupId`，查询该清单下的默认分组 ID。
     - Insert `task`.
     - **发送 MQ 消息**: topic=`task-events`, tag=`CREATE`, body=`{taskId, userId, title, ...}`.
3. **拖拽排序 (Reordering)**
   - **接口**: `POST /tasks/reorder`
   - **输入**: `taskGroupId`, `sortedTaskIds: [101, 105, 102...]` (前端排好序的ID列表).
   - **逻辑**:
     - 遍历 `sortedTaskIds`，批量更新 `sort_order` 字段 (或者使用 `CASE WHEN` 语句一次性更新)。
     - `UPDATE task SET sort_order = ? WHERE id = ?`

#### 2.1.2 数据库实体 (Entity)

对应 `smart_todo_task` 库中的四张表。使用 MyBatis Plus 生成 Entity/Mapper/Service。

### 2.2 动态服务 (Activity Service) - 端口 8030

负责“写”的高吞吐和“读”的聚合。

#### 2.2.1 消息消费 (MQ Consumer)

- **监听**: Topic `task-events`
- **逻辑**:
  1. 解析消息体。
  2. 构造 `ActivityLog` 对象。
  3. 查询 Redis 缓存 `user_feed:{userId}`。
  4. **写库**: Insert `activity_log`.
  5. **写缓存**: `LPUSH user_feed:{userId}` (保持最新的 50 条).

#### 2.2.2 动态流查询

- **接口**: `GET /activities/feed`
- **逻辑**:
  - 先读 Redis，若有数据直接返回。
  - 若 Redis 为空或需要加载更多（分页），查 MySQL `activity_log` 表 (按 `created_at` 倒序)。
  - **数据清洗**: 后端按日期 (yyyy-MM-dd) 将数据分组，返回给前端嵌套结构。

### 2.3 AI 服务 (AI Agent Service) - 端口 8040

#### 2.3.1 意图识别与执行

- **Step 1**: 构建 Prompt。
  - *System*: "你是一个任务管理助手。当前用户的清单结构如下：[JSON结构]。请识别用户意图。"
  - *User*: "明天下午开会"
- **Step 2**: 调用 LLM (如通义千问/ChatGPT)。
- **Step 3**: 解析 LLM 返回的 JSON。
  - `{ "action": "create_task", "params": { "title": "开会", "due_time": "2023-12-11 15:00", "list_id": 10 } }`
- **Step 4**: 通过 Feign Client 调用 `Task Service` 的 API。

## 3. 接口文档规范 (API Documentation)

采用 RESTful 风格。以下列举核心接口。

### 3.1 任务相关 (Task)

| 方法     | 路径                   | 描述                   | 请求参数示例                          | 响应数据                      |
| -------- | ---------------------- | ---------------------- | ------------------------------------- | ----------------------------- |
| **POST** | `/v1/tasks`            | 创建任务               | `{"title":"买牛奶", "groupId": 5}`    | `{"id": 1001}`                |
| **PUT**  | `/v1/tasks/{id}`       | 修改任务               | `{"status": 1, "description": "..."}` | `true`                        |
| **POST** | `/v1/tasks/reorder`    | 拖拽排序               | `{"groupId": 5, "taskIds": [1,3,2]}`  | `true`                        |
| **GET**  | `/v1/lists/{id}/tasks` | 获取清单下所有任务     | `?showCompleted=true`                 | `[{"id":1, "children":[]}]`   |
| **GET**  | `/v1/tasks/{id}`       | 获取任务详情(含子任务) | -                                     | `{"id":1, "subtasks": [...]}` |

### 3.2 清单与分组 (List & Group)

| 方法     | 路径                    | 描述             | 请求参数                        |
| -------- | ----------------------- | ---------------- | ------------------------------- |
| **GET**  | `/v1/sidebar/structure` | 获取侧边栏完整树 | 无 (基于当前 userId)            |
| **POST** | `/v1/lists`             | 新建清单         | `{"name":"工作", "groupId": 1}` |
| **POST** | `/v1/task-groups`       | 新建任务分组     | `{"name":"待办", "listId": 10}` |

### 3.3 动态 (Activity)

| 方法    | 路径                       | 描述             | Query 参数         |
| ------- | -------------------------- | ---------------- | ------------------ |
| **GET** | `/v1/activities/feed`      | 获取全局动态流   | `page=1&size=20`   |
| **GET** | `/v1/activities/list/{id}` | 获取特定清单动态 | `listId=10&page=1` |

## 4. 项目开发计划 (Development Roadmap)

### 阶段一：基础设施与地基

- [Infra] 搭建 Nacos, RocketMQ, MySQL, Redis 环境。
- [Code] 创建 Maven 父工程，划分模块。
- [DB] 执行 `database_schema.sql` 建表。
- [Auth] 完成 JWT 鉴权过滤器 (Gateway) 和 简单登录接口 (Auth Service)。
- **里程碑**: 接口能调通，Token 能生成和解析。

### 阶段二：核心业务攻坚 

- [Task] 实现 ListGroup/List/TaskGroup/Task 的 CRUD。
- [Task] **重点**: 实现“用户注册后的默认数据初始化”逻辑。
- [Task] **重点**: 实现“无限子任务”的递归/组装查询。
- [Task] 实现拖拽排序接口 (`reorder`)。
- [FE] 前端侧边栏和任务看板联调。
- **里程碑**: 用户可以完整管理自己的任务清单。

### 阶段三：动态流与异步解耦 

- [MQ] Task Service 接入 RocketMQ，发送 `TaskCreated`/`TaskUpdated` 事件。
- [Activity] 编写消费者，入库 `activity_log`。
- [Activity] 实现按日期分组的 Feed 流查询接口。
- **里程碑**: 右侧“动态”栏能实时滚出操作日志。

### 阶段四：AI 智能化与优化 

- [AI] 对接 LLM API (Spring AI)。
- [AI] 编写 Prompt Template，调试意图识别准确率。
- [Ops] 引入 Sentinel 做限流熔断。
- [Ops] Docker 镜像构建与部署脚本编写。
- **里程碑**: 可以对悬浮球说话，自动创建任务。